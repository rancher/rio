// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package fakes

import (
	context "context"
	sync "sync"

	v1 "github.com/rancher/rio/pkg/generated/controllers/core/v1"
	generic "github.com/rancher/wrangler/pkg/generic"
	v1a "k8s.io/api/core/v1"
	v1b "k8s.io/apimachinery/pkg/apis/meta/v1"
	labels "k8s.io/apimachinery/pkg/labels"
	schema "k8s.io/apimachinery/pkg/runtime/schema"
	types "k8s.io/apimachinery/pkg/types"
	watch "k8s.io/apimachinery/pkg/watch"
	cache "k8s.io/client-go/tools/cache"
)

var (
	lockPersistentVolumeClaimControllerMockAddGenericHandler       sync.RWMutex
	lockPersistentVolumeClaimControllerMockAddGenericRemoveHandler sync.RWMutex
	lockPersistentVolumeClaimControllerMockCache                   sync.RWMutex
	lockPersistentVolumeClaimControllerMockCreate                  sync.RWMutex
	lockPersistentVolumeClaimControllerMockDelete                  sync.RWMutex
	lockPersistentVolumeClaimControllerMockEnqueue                 sync.RWMutex
	lockPersistentVolumeClaimControllerMockGet                     sync.RWMutex
	lockPersistentVolumeClaimControllerMockGroupVersionKind        sync.RWMutex
	lockPersistentVolumeClaimControllerMockInformer                sync.RWMutex
	lockPersistentVolumeClaimControllerMockList                    sync.RWMutex
	lockPersistentVolumeClaimControllerMockOnChange                sync.RWMutex
	lockPersistentVolumeClaimControllerMockOnRemove                sync.RWMutex
	lockPersistentVolumeClaimControllerMockPatch                   sync.RWMutex
	lockPersistentVolumeClaimControllerMockUpdate                  sync.RWMutex
	lockPersistentVolumeClaimControllerMockUpdateStatus            sync.RWMutex
	lockPersistentVolumeClaimControllerMockUpdater                 sync.RWMutex
	lockPersistentVolumeClaimControllerMockWatch                   sync.RWMutex
)

// Ensure, that PersistentVolumeClaimControllerMock does implement PersistentVolumeClaimController.
// If this is not the case, regenerate this file with moq.
var _ v1.PersistentVolumeClaimController = &PersistentVolumeClaimControllerMock{}

// PersistentVolumeClaimControllerMock is a mock implementation of PersistentVolumeClaimController.
//
//     func TestSomethingThatUsesPersistentVolumeClaimController(t *testing.T) {
//
//         // make and configure a mocked PersistentVolumeClaimController
//         mockedPersistentVolumeClaimController := &PersistentVolumeClaimControllerMock{
//             AddGenericHandlerFunc: func(ctx context.Context, name string, handler generic.Handler)  {
// 	               panic("mock out the AddGenericHandler method")
//             },
//             AddGenericRemoveHandlerFunc: func(ctx context.Context, name string, handler generic.Handler)  {
// 	               panic("mock out the AddGenericRemoveHandler method")
//             },
//             CacheFunc: func() v1.PersistentVolumeClaimCache {
// 	               panic("mock out the Cache method")
//             },
//             CreateFunc: func(in1 *v1a.PersistentVolumeClaim) (*v1a.PersistentVolumeClaim, error) {
// 	               panic("mock out the Create method")
//             },
//             DeleteFunc: func(namespace string, name string, options *v1b.DeleteOptions) error {
// 	               panic("mock out the Delete method")
//             },
//             EnqueueFunc: func(namespace string, name string)  {
// 	               panic("mock out the Enqueue method")
//             },
//             GetFunc: func(namespace string, name string, options v1b.GetOptions) (*v1a.PersistentVolumeClaim, error) {
// 	               panic("mock out the Get method")
//             },
//             GroupVersionKindFunc: func() schema.GroupVersionKind {
// 	               panic("mock out the GroupVersionKind method")
//             },
//             InformerFunc: func() cache.SharedIndexInformer {
// 	               panic("mock out the Informer method")
//             },
//             ListFunc: func(namespace string, opts v1b.ListOptions) (*v1a.PersistentVolumeClaimList, error) {
// 	               panic("mock out the List method")
//             },
//             OnChangeFunc: func(ctx context.Context, name string, sync v1.PersistentVolumeClaimHandler)  {
// 	               panic("mock out the OnChange method")
//             },
//             OnRemoveFunc: func(ctx context.Context, name string, sync v1.PersistentVolumeClaimHandler)  {
// 	               panic("mock out the OnRemove method")
//             },
//             PatchFunc: func(namespace string, name string, pt types.PatchType, data []byte, subresources ...string) (*v1a.PersistentVolumeClaim, error) {
// 	               panic("mock out the Patch method")
//             },
//             UpdateFunc: func(in1 *v1a.PersistentVolumeClaim) (*v1a.PersistentVolumeClaim, error) {
// 	               panic("mock out the Update method")
//             },
//             UpdateStatusFunc: func(in1 *v1a.PersistentVolumeClaim) (*v1a.PersistentVolumeClaim, error) {
// 	               panic("mock out the UpdateStatus method")
//             },
//             UpdaterFunc: func() generic.Updater {
// 	               panic("mock out the Updater method")
//             },
//             WatchFunc: func(namespace string, opts v1b.ListOptions) (watch.Interface, error) {
// 	               panic("mock out the Watch method")
//             },
//         }
//
//         // use mockedPersistentVolumeClaimController in code that requires PersistentVolumeClaimController
//         // and then make assertions.
//
//     }
type PersistentVolumeClaimControllerMock struct {
	// AddGenericHandlerFunc mocks the AddGenericHandler method.
	AddGenericHandlerFunc func(ctx context.Context, name string, handler generic.Handler)

	// AddGenericRemoveHandlerFunc mocks the AddGenericRemoveHandler method.
	AddGenericRemoveHandlerFunc func(ctx context.Context, name string, handler generic.Handler)

	// CacheFunc mocks the Cache method.
	CacheFunc func() v1.PersistentVolumeClaimCache

	// CreateFunc mocks the Create method.
	CreateFunc func(in1 *v1a.PersistentVolumeClaim) (*v1a.PersistentVolumeClaim, error)

	// DeleteFunc mocks the Delete method.
	DeleteFunc func(namespace string, name string, options *v1b.DeleteOptions) error

	// EnqueueFunc mocks the Enqueue method.
	EnqueueFunc func(namespace string, name string)

	// GetFunc mocks the Get method.
	GetFunc func(namespace string, name string, options v1b.GetOptions) (*v1a.PersistentVolumeClaim, error)

	// GroupVersionKindFunc mocks the GroupVersionKind method.
	GroupVersionKindFunc func() schema.GroupVersionKind

	// InformerFunc mocks the Informer method.
	InformerFunc func() cache.SharedIndexInformer

	// ListFunc mocks the List method.
	ListFunc func(namespace string, opts v1b.ListOptions) (*v1a.PersistentVolumeClaimList, error)

	// OnChangeFunc mocks the OnChange method.
	OnChangeFunc func(ctx context.Context, name string, sync v1.PersistentVolumeClaimHandler)

	// OnRemoveFunc mocks the OnRemove method.
	OnRemoveFunc func(ctx context.Context, name string, sync v1.PersistentVolumeClaimHandler)

	// PatchFunc mocks the Patch method.
	PatchFunc func(namespace string, name string, pt types.PatchType, data []byte, subresources ...string) (*v1a.PersistentVolumeClaim, error)

	// UpdateFunc mocks the Update method.
	UpdateFunc func(in1 *v1a.PersistentVolumeClaim) (*v1a.PersistentVolumeClaim, error)

	// UpdateStatusFunc mocks the UpdateStatus method.
	UpdateStatusFunc func(in1 *v1a.PersistentVolumeClaim) (*v1a.PersistentVolumeClaim, error)

	// UpdaterFunc mocks the Updater method.
	UpdaterFunc func() generic.Updater

	// WatchFunc mocks the Watch method.
	WatchFunc func(namespace string, opts v1b.ListOptions) (watch.Interface, error)

	// calls tracks calls to the methods.
	calls struct {
		// AddGenericHandler holds details about calls to the AddGenericHandler method.
		AddGenericHandler []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Name is the name argument value.
			Name string
			// Handler is the handler argument value.
			Handler generic.Handler
		}
		// AddGenericRemoveHandler holds details about calls to the AddGenericRemoveHandler method.
		AddGenericRemoveHandler []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Name is the name argument value.
			Name string
			// Handler is the handler argument value.
			Handler generic.Handler
		}
		// Cache holds details about calls to the Cache method.
		Cache []struct {
		}
		// Create holds details about calls to the Create method.
		Create []struct {
			// In1 is the in1 argument value.
			In1 *v1a.PersistentVolumeClaim
		}
		// Delete holds details about calls to the Delete method.
		Delete []struct {
			// Namespace is the namespace argument value.
			Namespace string
			// Name is the name argument value.
			Name string
			// Options is the options argument value.
			Options *v1b.DeleteOptions
		}
		// Enqueue holds details about calls to the Enqueue method.
		Enqueue []struct {
			// Namespace is the namespace argument value.
			Namespace string
			// Name is the name argument value.
			Name string
		}
		// Get holds details about calls to the Get method.
		Get []struct {
			// Namespace is the namespace argument value.
			Namespace string
			// Name is the name argument value.
			Name string
			// Options is the options argument value.
			Options v1b.GetOptions
		}
		// GroupVersionKind holds details about calls to the GroupVersionKind method.
		GroupVersionKind []struct {
		}
		// Informer holds details about calls to the Informer method.
		Informer []struct {
		}
		// List holds details about calls to the List method.
		List []struct {
			// Namespace is the namespace argument value.
			Namespace string
			// Opts is the opts argument value.
			Opts v1b.ListOptions
		}
		// OnChange holds details about calls to the OnChange method.
		OnChange []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Name is the name argument value.
			Name string
			// Sync is the sync argument value.
			Sync v1.PersistentVolumeClaimHandler
		}
		// OnRemove holds details about calls to the OnRemove method.
		OnRemove []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Name is the name argument value.
			Name string
			// Sync is the sync argument value.
			Sync v1.PersistentVolumeClaimHandler
		}
		// Patch holds details about calls to the Patch method.
		Patch []struct {
			// Namespace is the namespace argument value.
			Namespace string
			// Name is the name argument value.
			Name string
			// Pt is the pt argument value.
			Pt types.PatchType
			// Data is the data argument value.
			Data []byte
			// Subresources is the subresources argument value.
			Subresources []string
		}
		// Update holds details about calls to the Update method.
		Update []struct {
			// In1 is the in1 argument value.
			In1 *v1a.PersistentVolumeClaim
		}
		// UpdateStatus holds details about calls to the UpdateStatus method.
		UpdateStatus []struct {
			// In1 is the in1 argument value.
			In1 *v1a.PersistentVolumeClaim
		}
		// Updater holds details about calls to the Updater method.
		Updater []struct {
		}
		// Watch holds details about calls to the Watch method.
		Watch []struct {
			// Namespace is the namespace argument value.
			Namespace string
			// Opts is the opts argument value.
			Opts v1b.ListOptions
		}
	}
}

// AddGenericHandler calls AddGenericHandlerFunc.
func (mock *PersistentVolumeClaimControllerMock) AddGenericHandler(ctx context.Context, name string, handler generic.Handler) {
	if mock.AddGenericHandlerFunc == nil {
		panic("PersistentVolumeClaimControllerMock.AddGenericHandlerFunc: method is nil but PersistentVolumeClaimController.AddGenericHandler was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Name    string
		Handler generic.Handler
	}{
		Ctx:     ctx,
		Name:    name,
		Handler: handler,
	}
	lockPersistentVolumeClaimControllerMockAddGenericHandler.Lock()
	mock.calls.AddGenericHandler = append(mock.calls.AddGenericHandler, callInfo)
	lockPersistentVolumeClaimControllerMockAddGenericHandler.Unlock()
	mock.AddGenericHandlerFunc(ctx, name, handler)
}

// AddGenericHandlerCalls gets all the calls that were made to AddGenericHandler.
// Check the length with:
//     len(mockedPersistentVolumeClaimController.AddGenericHandlerCalls())
func (mock *PersistentVolumeClaimControllerMock) AddGenericHandlerCalls() []struct {
	Ctx     context.Context
	Name    string
	Handler generic.Handler
} {
	var calls []struct {
		Ctx     context.Context
		Name    string
		Handler generic.Handler
	}
	lockPersistentVolumeClaimControllerMockAddGenericHandler.RLock()
	calls = mock.calls.AddGenericHandler
	lockPersistentVolumeClaimControllerMockAddGenericHandler.RUnlock()
	return calls
}

// AddGenericRemoveHandler calls AddGenericRemoveHandlerFunc.
func (mock *PersistentVolumeClaimControllerMock) AddGenericRemoveHandler(ctx context.Context, name string, handler generic.Handler) {
	if mock.AddGenericRemoveHandlerFunc == nil {
		panic("PersistentVolumeClaimControllerMock.AddGenericRemoveHandlerFunc: method is nil but PersistentVolumeClaimController.AddGenericRemoveHandler was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Name    string
		Handler generic.Handler
	}{
		Ctx:     ctx,
		Name:    name,
		Handler: handler,
	}
	lockPersistentVolumeClaimControllerMockAddGenericRemoveHandler.Lock()
	mock.calls.AddGenericRemoveHandler = append(mock.calls.AddGenericRemoveHandler, callInfo)
	lockPersistentVolumeClaimControllerMockAddGenericRemoveHandler.Unlock()
	mock.AddGenericRemoveHandlerFunc(ctx, name, handler)
}

// AddGenericRemoveHandlerCalls gets all the calls that were made to AddGenericRemoveHandler.
// Check the length with:
//     len(mockedPersistentVolumeClaimController.AddGenericRemoveHandlerCalls())
func (mock *PersistentVolumeClaimControllerMock) AddGenericRemoveHandlerCalls() []struct {
	Ctx     context.Context
	Name    string
	Handler generic.Handler
} {
	var calls []struct {
		Ctx     context.Context
		Name    string
		Handler generic.Handler
	}
	lockPersistentVolumeClaimControllerMockAddGenericRemoveHandler.RLock()
	calls = mock.calls.AddGenericRemoveHandler
	lockPersistentVolumeClaimControllerMockAddGenericRemoveHandler.RUnlock()
	return calls
}

// Cache calls CacheFunc.
func (mock *PersistentVolumeClaimControllerMock) Cache() v1.PersistentVolumeClaimCache {
	if mock.CacheFunc == nil {
		panic("PersistentVolumeClaimControllerMock.CacheFunc: method is nil but PersistentVolumeClaimController.Cache was just called")
	}
	callInfo := struct {
	}{}
	lockPersistentVolumeClaimControllerMockCache.Lock()
	mock.calls.Cache = append(mock.calls.Cache, callInfo)
	lockPersistentVolumeClaimControllerMockCache.Unlock()
	return mock.CacheFunc()
}

// CacheCalls gets all the calls that were made to Cache.
// Check the length with:
//     len(mockedPersistentVolumeClaimController.CacheCalls())
func (mock *PersistentVolumeClaimControllerMock) CacheCalls() []struct {
} {
	var calls []struct {
	}
	lockPersistentVolumeClaimControllerMockCache.RLock()
	calls = mock.calls.Cache
	lockPersistentVolumeClaimControllerMockCache.RUnlock()
	return calls
}

// Create calls CreateFunc.
func (mock *PersistentVolumeClaimControllerMock) Create(in1 *v1a.PersistentVolumeClaim) (*v1a.PersistentVolumeClaim, error) {
	if mock.CreateFunc == nil {
		panic("PersistentVolumeClaimControllerMock.CreateFunc: method is nil but PersistentVolumeClaimController.Create was just called")
	}
	callInfo := struct {
		In1 *v1a.PersistentVolumeClaim
	}{
		In1: in1,
	}
	lockPersistentVolumeClaimControllerMockCreate.Lock()
	mock.calls.Create = append(mock.calls.Create, callInfo)
	lockPersistentVolumeClaimControllerMockCreate.Unlock()
	return mock.CreateFunc(in1)
}

// CreateCalls gets all the calls that were made to Create.
// Check the length with:
//     len(mockedPersistentVolumeClaimController.CreateCalls())
func (mock *PersistentVolumeClaimControllerMock) CreateCalls() []struct {
	In1 *v1a.PersistentVolumeClaim
} {
	var calls []struct {
		In1 *v1a.PersistentVolumeClaim
	}
	lockPersistentVolumeClaimControllerMockCreate.RLock()
	calls = mock.calls.Create
	lockPersistentVolumeClaimControllerMockCreate.RUnlock()
	return calls
}

// Delete calls DeleteFunc.
func (mock *PersistentVolumeClaimControllerMock) Delete(namespace string, name string, options *v1b.DeleteOptions) error {
	if mock.DeleteFunc == nil {
		panic("PersistentVolumeClaimControllerMock.DeleteFunc: method is nil but PersistentVolumeClaimController.Delete was just called")
	}
	callInfo := struct {
		Namespace string
		Name      string
		Options   *v1b.DeleteOptions
	}{
		Namespace: namespace,
		Name:      name,
		Options:   options,
	}
	lockPersistentVolumeClaimControllerMockDelete.Lock()
	mock.calls.Delete = append(mock.calls.Delete, callInfo)
	lockPersistentVolumeClaimControllerMockDelete.Unlock()
	return mock.DeleteFunc(namespace, name, options)
}

// DeleteCalls gets all the calls that were made to Delete.
// Check the length with:
//     len(mockedPersistentVolumeClaimController.DeleteCalls())
func (mock *PersistentVolumeClaimControllerMock) DeleteCalls() []struct {
	Namespace string
	Name      string
	Options   *v1b.DeleteOptions
} {
	var calls []struct {
		Namespace string
		Name      string
		Options   *v1b.DeleteOptions
	}
	lockPersistentVolumeClaimControllerMockDelete.RLock()
	calls = mock.calls.Delete
	lockPersistentVolumeClaimControllerMockDelete.RUnlock()
	return calls
}

// Enqueue calls EnqueueFunc.
func (mock *PersistentVolumeClaimControllerMock) Enqueue(namespace string, name string) {
	if mock.EnqueueFunc == nil {
		panic("PersistentVolumeClaimControllerMock.EnqueueFunc: method is nil but PersistentVolumeClaimController.Enqueue was just called")
	}
	callInfo := struct {
		Namespace string
		Name      string
	}{
		Namespace: namespace,
		Name:      name,
	}
	lockPersistentVolumeClaimControllerMockEnqueue.Lock()
	mock.calls.Enqueue = append(mock.calls.Enqueue, callInfo)
	lockPersistentVolumeClaimControllerMockEnqueue.Unlock()
	mock.EnqueueFunc(namespace, name)
}

// EnqueueCalls gets all the calls that were made to Enqueue.
// Check the length with:
//     len(mockedPersistentVolumeClaimController.EnqueueCalls())
func (mock *PersistentVolumeClaimControllerMock) EnqueueCalls() []struct {
	Namespace string
	Name      string
} {
	var calls []struct {
		Namespace string
		Name      string
	}
	lockPersistentVolumeClaimControllerMockEnqueue.RLock()
	calls = mock.calls.Enqueue
	lockPersistentVolumeClaimControllerMockEnqueue.RUnlock()
	return calls
}

// Get calls GetFunc.
func (mock *PersistentVolumeClaimControllerMock) Get(namespace string, name string, options v1b.GetOptions) (*v1a.PersistentVolumeClaim, error) {
	if mock.GetFunc == nil {
		panic("PersistentVolumeClaimControllerMock.GetFunc: method is nil but PersistentVolumeClaimController.Get was just called")
	}
	callInfo := struct {
		Namespace string
		Name      string
		Options   v1b.GetOptions
	}{
		Namespace: namespace,
		Name:      name,
		Options:   options,
	}
	lockPersistentVolumeClaimControllerMockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	lockPersistentVolumeClaimControllerMockGet.Unlock()
	return mock.GetFunc(namespace, name, options)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//     len(mockedPersistentVolumeClaimController.GetCalls())
func (mock *PersistentVolumeClaimControllerMock) GetCalls() []struct {
	Namespace string
	Name      string
	Options   v1b.GetOptions
} {
	var calls []struct {
		Namespace string
		Name      string
		Options   v1b.GetOptions
	}
	lockPersistentVolumeClaimControllerMockGet.RLock()
	calls = mock.calls.Get
	lockPersistentVolumeClaimControllerMockGet.RUnlock()
	return calls
}

// GroupVersionKind calls GroupVersionKindFunc.
func (mock *PersistentVolumeClaimControllerMock) GroupVersionKind() schema.GroupVersionKind {
	if mock.GroupVersionKindFunc == nil {
		panic("PersistentVolumeClaimControllerMock.GroupVersionKindFunc: method is nil but PersistentVolumeClaimController.GroupVersionKind was just called")
	}
	callInfo := struct {
	}{}
	lockPersistentVolumeClaimControllerMockGroupVersionKind.Lock()
	mock.calls.GroupVersionKind = append(mock.calls.GroupVersionKind, callInfo)
	lockPersistentVolumeClaimControllerMockGroupVersionKind.Unlock()
	return mock.GroupVersionKindFunc()
}

// GroupVersionKindCalls gets all the calls that were made to GroupVersionKind.
// Check the length with:
//     len(mockedPersistentVolumeClaimController.GroupVersionKindCalls())
func (mock *PersistentVolumeClaimControllerMock) GroupVersionKindCalls() []struct {
} {
	var calls []struct {
	}
	lockPersistentVolumeClaimControllerMockGroupVersionKind.RLock()
	calls = mock.calls.GroupVersionKind
	lockPersistentVolumeClaimControllerMockGroupVersionKind.RUnlock()
	return calls
}

// Informer calls InformerFunc.
func (mock *PersistentVolumeClaimControllerMock) Informer() cache.SharedIndexInformer {
	if mock.InformerFunc == nil {
		panic("PersistentVolumeClaimControllerMock.InformerFunc: method is nil but PersistentVolumeClaimController.Informer was just called")
	}
	callInfo := struct {
	}{}
	lockPersistentVolumeClaimControllerMockInformer.Lock()
	mock.calls.Informer = append(mock.calls.Informer, callInfo)
	lockPersistentVolumeClaimControllerMockInformer.Unlock()
	return mock.InformerFunc()
}

// InformerCalls gets all the calls that were made to Informer.
// Check the length with:
//     len(mockedPersistentVolumeClaimController.InformerCalls())
func (mock *PersistentVolumeClaimControllerMock) InformerCalls() []struct {
} {
	var calls []struct {
	}
	lockPersistentVolumeClaimControllerMockInformer.RLock()
	calls = mock.calls.Informer
	lockPersistentVolumeClaimControllerMockInformer.RUnlock()
	return calls
}

// List calls ListFunc.
func (mock *PersistentVolumeClaimControllerMock) List(namespace string, opts v1b.ListOptions) (*v1a.PersistentVolumeClaimList, error) {
	if mock.ListFunc == nil {
		panic("PersistentVolumeClaimControllerMock.ListFunc: method is nil but PersistentVolumeClaimController.List was just called")
	}
	callInfo := struct {
		Namespace string
		Opts      v1b.ListOptions
	}{
		Namespace: namespace,
		Opts:      opts,
	}
	lockPersistentVolumeClaimControllerMockList.Lock()
	mock.calls.List = append(mock.calls.List, callInfo)
	lockPersistentVolumeClaimControllerMockList.Unlock()
	return mock.ListFunc(namespace, opts)
}

// ListCalls gets all the calls that were made to List.
// Check the length with:
//     len(mockedPersistentVolumeClaimController.ListCalls())
func (mock *PersistentVolumeClaimControllerMock) ListCalls() []struct {
	Namespace string
	Opts      v1b.ListOptions
} {
	var calls []struct {
		Namespace string
		Opts      v1b.ListOptions
	}
	lockPersistentVolumeClaimControllerMockList.RLock()
	calls = mock.calls.List
	lockPersistentVolumeClaimControllerMockList.RUnlock()
	return calls
}

// OnChange calls OnChangeFunc.
func (mock *PersistentVolumeClaimControllerMock) OnChange(ctx context.Context, name string, sync v1.PersistentVolumeClaimHandler) {
	if mock.OnChangeFunc == nil {
		panic("PersistentVolumeClaimControllerMock.OnChangeFunc: method is nil but PersistentVolumeClaimController.OnChange was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Name string
		Sync v1.PersistentVolumeClaimHandler
	}{
		Ctx:  ctx,
		Name: name,
		Sync: sync,
	}
	lockPersistentVolumeClaimControllerMockOnChange.Lock()
	mock.calls.OnChange = append(mock.calls.OnChange, callInfo)
	lockPersistentVolumeClaimControllerMockOnChange.Unlock()
	mock.OnChangeFunc(ctx, name, sync)
}

// OnChangeCalls gets all the calls that were made to OnChange.
// Check the length with:
//     len(mockedPersistentVolumeClaimController.OnChangeCalls())
func (mock *PersistentVolumeClaimControllerMock) OnChangeCalls() []struct {
	Ctx  context.Context
	Name string
	Sync v1.PersistentVolumeClaimHandler
} {
	var calls []struct {
		Ctx  context.Context
		Name string
		Sync v1.PersistentVolumeClaimHandler
	}
	lockPersistentVolumeClaimControllerMockOnChange.RLock()
	calls = mock.calls.OnChange
	lockPersistentVolumeClaimControllerMockOnChange.RUnlock()
	return calls
}

// OnRemove calls OnRemoveFunc.
func (mock *PersistentVolumeClaimControllerMock) OnRemove(ctx context.Context, name string, sync v1.PersistentVolumeClaimHandler) {
	if mock.OnRemoveFunc == nil {
		panic("PersistentVolumeClaimControllerMock.OnRemoveFunc: method is nil but PersistentVolumeClaimController.OnRemove was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Name string
		Sync v1.PersistentVolumeClaimHandler
	}{
		Ctx:  ctx,
		Name: name,
		Sync: sync,
	}
	lockPersistentVolumeClaimControllerMockOnRemove.Lock()
	mock.calls.OnRemove = append(mock.calls.OnRemove, callInfo)
	lockPersistentVolumeClaimControllerMockOnRemove.Unlock()
	mock.OnRemoveFunc(ctx, name, sync)
}

// OnRemoveCalls gets all the calls that were made to OnRemove.
// Check the length with:
//     len(mockedPersistentVolumeClaimController.OnRemoveCalls())
func (mock *PersistentVolumeClaimControllerMock) OnRemoveCalls() []struct {
	Ctx  context.Context
	Name string
	Sync v1.PersistentVolumeClaimHandler
} {
	var calls []struct {
		Ctx  context.Context
		Name string
		Sync v1.PersistentVolumeClaimHandler
	}
	lockPersistentVolumeClaimControllerMockOnRemove.RLock()
	calls = mock.calls.OnRemove
	lockPersistentVolumeClaimControllerMockOnRemove.RUnlock()
	return calls
}

// Patch calls PatchFunc.
func (mock *PersistentVolumeClaimControllerMock) Patch(namespace string, name string, pt types.PatchType, data []byte, subresources ...string) (*v1a.PersistentVolumeClaim, error) {
	if mock.PatchFunc == nil {
		panic("PersistentVolumeClaimControllerMock.PatchFunc: method is nil but PersistentVolumeClaimController.Patch was just called")
	}
	callInfo := struct {
		Namespace    string
		Name         string
		Pt           types.PatchType
		Data         []byte
		Subresources []string
	}{
		Namespace:    namespace,
		Name:         name,
		Pt:           pt,
		Data:         data,
		Subresources: subresources,
	}
	lockPersistentVolumeClaimControllerMockPatch.Lock()
	mock.calls.Patch = append(mock.calls.Patch, callInfo)
	lockPersistentVolumeClaimControllerMockPatch.Unlock()
	return mock.PatchFunc(namespace, name, pt, data, subresources...)
}

// PatchCalls gets all the calls that were made to Patch.
// Check the length with:
//     len(mockedPersistentVolumeClaimController.PatchCalls())
func (mock *PersistentVolumeClaimControllerMock) PatchCalls() []struct {
	Namespace    string
	Name         string
	Pt           types.PatchType
	Data         []byte
	Subresources []string
} {
	var calls []struct {
		Namespace    string
		Name         string
		Pt           types.PatchType
		Data         []byte
		Subresources []string
	}
	lockPersistentVolumeClaimControllerMockPatch.RLock()
	calls = mock.calls.Patch
	lockPersistentVolumeClaimControllerMockPatch.RUnlock()
	return calls
}

// Update calls UpdateFunc.
func (mock *PersistentVolumeClaimControllerMock) Update(in1 *v1a.PersistentVolumeClaim) (*v1a.PersistentVolumeClaim, error) {
	if mock.UpdateFunc == nil {
		panic("PersistentVolumeClaimControllerMock.UpdateFunc: method is nil but PersistentVolumeClaimController.Update was just called")
	}
	callInfo := struct {
		In1 *v1a.PersistentVolumeClaim
	}{
		In1: in1,
	}
	lockPersistentVolumeClaimControllerMockUpdate.Lock()
	mock.calls.Update = append(mock.calls.Update, callInfo)
	lockPersistentVolumeClaimControllerMockUpdate.Unlock()
	return mock.UpdateFunc(in1)
}

// UpdateCalls gets all the calls that were made to Update.
// Check the length with:
//     len(mockedPersistentVolumeClaimController.UpdateCalls())
func (mock *PersistentVolumeClaimControllerMock) UpdateCalls() []struct {
	In1 *v1a.PersistentVolumeClaim
} {
	var calls []struct {
		In1 *v1a.PersistentVolumeClaim
	}
	lockPersistentVolumeClaimControllerMockUpdate.RLock()
	calls = mock.calls.Update
	lockPersistentVolumeClaimControllerMockUpdate.RUnlock()
	return calls
}

// UpdateStatus calls UpdateStatusFunc.
func (mock *PersistentVolumeClaimControllerMock) UpdateStatus(in1 *v1a.PersistentVolumeClaim) (*v1a.PersistentVolumeClaim, error) {
	if mock.UpdateStatusFunc == nil {
		panic("PersistentVolumeClaimControllerMock.UpdateStatusFunc: method is nil but PersistentVolumeClaimController.UpdateStatus was just called")
	}
	callInfo := struct {
		In1 *v1a.PersistentVolumeClaim
	}{
		In1: in1,
	}
	lockPersistentVolumeClaimControllerMockUpdateStatus.Lock()
	mock.calls.UpdateStatus = append(mock.calls.UpdateStatus, callInfo)
	lockPersistentVolumeClaimControllerMockUpdateStatus.Unlock()
	return mock.UpdateStatusFunc(in1)
}

// UpdateStatusCalls gets all the calls that were made to UpdateStatus.
// Check the length with:
//     len(mockedPersistentVolumeClaimController.UpdateStatusCalls())
func (mock *PersistentVolumeClaimControllerMock) UpdateStatusCalls() []struct {
	In1 *v1a.PersistentVolumeClaim
} {
	var calls []struct {
		In1 *v1a.PersistentVolumeClaim
	}
	lockPersistentVolumeClaimControllerMockUpdateStatus.RLock()
	calls = mock.calls.UpdateStatus
	lockPersistentVolumeClaimControllerMockUpdateStatus.RUnlock()
	return calls
}

// Updater calls UpdaterFunc.
func (mock *PersistentVolumeClaimControllerMock) Updater() generic.Updater {
	if mock.UpdaterFunc == nil {
		panic("PersistentVolumeClaimControllerMock.UpdaterFunc: method is nil but PersistentVolumeClaimController.Updater was just called")
	}
	callInfo := struct {
	}{}
	lockPersistentVolumeClaimControllerMockUpdater.Lock()
	mock.calls.Updater = append(mock.calls.Updater, callInfo)
	lockPersistentVolumeClaimControllerMockUpdater.Unlock()
	return mock.UpdaterFunc()
}

// UpdaterCalls gets all the calls that were made to Updater.
// Check the length with:
//     len(mockedPersistentVolumeClaimController.UpdaterCalls())
func (mock *PersistentVolumeClaimControllerMock) UpdaterCalls() []struct {
} {
	var calls []struct {
	}
	lockPersistentVolumeClaimControllerMockUpdater.RLock()
	calls = mock.calls.Updater
	lockPersistentVolumeClaimControllerMockUpdater.RUnlock()
	return calls
}

// Watch calls WatchFunc.
func (mock *PersistentVolumeClaimControllerMock) Watch(namespace string, opts v1b.ListOptions) (watch.Interface, error) {
	if mock.WatchFunc == nil {
		panic("PersistentVolumeClaimControllerMock.WatchFunc: method is nil but PersistentVolumeClaimController.Watch was just called")
	}
	callInfo := struct {
		Namespace string
		Opts      v1b.ListOptions
	}{
		Namespace: namespace,
		Opts:      opts,
	}
	lockPersistentVolumeClaimControllerMockWatch.Lock()
	mock.calls.Watch = append(mock.calls.Watch, callInfo)
	lockPersistentVolumeClaimControllerMockWatch.Unlock()
	return mock.WatchFunc(namespace, opts)
}

// WatchCalls gets all the calls that were made to Watch.
// Check the length with:
//     len(mockedPersistentVolumeClaimController.WatchCalls())
func (mock *PersistentVolumeClaimControllerMock) WatchCalls() []struct {
	Namespace string
	Opts      v1b.ListOptions
} {
	var calls []struct {
		Namespace string
		Opts      v1b.ListOptions
	}
	lockPersistentVolumeClaimControllerMockWatch.RLock()
	calls = mock.calls.Watch
	lockPersistentVolumeClaimControllerMockWatch.RUnlock()
	return calls
}

var (
	lockPersistentVolumeClaimClientMockCreate       sync.RWMutex
	lockPersistentVolumeClaimClientMockDelete       sync.RWMutex
	lockPersistentVolumeClaimClientMockGet          sync.RWMutex
	lockPersistentVolumeClaimClientMockList         sync.RWMutex
	lockPersistentVolumeClaimClientMockPatch        sync.RWMutex
	lockPersistentVolumeClaimClientMockUpdate       sync.RWMutex
	lockPersistentVolumeClaimClientMockUpdateStatus sync.RWMutex
	lockPersistentVolumeClaimClientMockWatch        sync.RWMutex
)

// Ensure, that PersistentVolumeClaimClientMock does implement PersistentVolumeClaimClient.
// If this is not the case, regenerate this file with moq.
var _ v1.PersistentVolumeClaimClient = &PersistentVolumeClaimClientMock{}

// PersistentVolumeClaimClientMock is a mock implementation of PersistentVolumeClaimClient.
//
//     func TestSomethingThatUsesPersistentVolumeClaimClient(t *testing.T) {
//
//         // make and configure a mocked PersistentVolumeClaimClient
//         mockedPersistentVolumeClaimClient := &PersistentVolumeClaimClientMock{
//             CreateFunc: func(in1 *v1a.PersistentVolumeClaim) (*v1a.PersistentVolumeClaim, error) {
// 	               panic("mock out the Create method")
//             },
//             DeleteFunc: func(namespace string, name string, options *v1b.DeleteOptions) error {
// 	               panic("mock out the Delete method")
//             },
//             GetFunc: func(namespace string, name string, options v1b.GetOptions) (*v1a.PersistentVolumeClaim, error) {
// 	               panic("mock out the Get method")
//             },
//             ListFunc: func(namespace string, opts v1b.ListOptions) (*v1a.PersistentVolumeClaimList, error) {
// 	               panic("mock out the List method")
//             },
//             PatchFunc: func(namespace string, name string, pt types.PatchType, data []byte, subresources ...string) (*v1a.PersistentVolumeClaim, error) {
// 	               panic("mock out the Patch method")
//             },
//             UpdateFunc: func(in1 *v1a.PersistentVolumeClaim) (*v1a.PersistentVolumeClaim, error) {
// 	               panic("mock out the Update method")
//             },
//             UpdateStatusFunc: func(in1 *v1a.PersistentVolumeClaim) (*v1a.PersistentVolumeClaim, error) {
// 	               panic("mock out the UpdateStatus method")
//             },
//             WatchFunc: func(namespace string, opts v1b.ListOptions) (watch.Interface, error) {
// 	               panic("mock out the Watch method")
//             },
//         }
//
//         // use mockedPersistentVolumeClaimClient in code that requires PersistentVolumeClaimClient
//         // and then make assertions.
//
//     }
type PersistentVolumeClaimClientMock struct {
	// CreateFunc mocks the Create method.
	CreateFunc func(in1 *v1a.PersistentVolumeClaim) (*v1a.PersistentVolumeClaim, error)

	// DeleteFunc mocks the Delete method.
	DeleteFunc func(namespace string, name string, options *v1b.DeleteOptions) error

	// GetFunc mocks the Get method.
	GetFunc func(namespace string, name string, options v1b.GetOptions) (*v1a.PersistentVolumeClaim, error)

	// ListFunc mocks the List method.
	ListFunc func(namespace string, opts v1b.ListOptions) (*v1a.PersistentVolumeClaimList, error)

	// PatchFunc mocks the Patch method.
	PatchFunc func(namespace string, name string, pt types.PatchType, data []byte, subresources ...string) (*v1a.PersistentVolumeClaim, error)

	// UpdateFunc mocks the Update method.
	UpdateFunc func(in1 *v1a.PersistentVolumeClaim) (*v1a.PersistentVolumeClaim, error)

	// UpdateStatusFunc mocks the UpdateStatus method.
	UpdateStatusFunc func(in1 *v1a.PersistentVolumeClaim) (*v1a.PersistentVolumeClaim, error)

	// WatchFunc mocks the Watch method.
	WatchFunc func(namespace string, opts v1b.ListOptions) (watch.Interface, error)

	// calls tracks calls to the methods.
	calls struct {
		// Create holds details about calls to the Create method.
		Create []struct {
			// In1 is the in1 argument value.
			In1 *v1a.PersistentVolumeClaim
		}
		// Delete holds details about calls to the Delete method.
		Delete []struct {
			// Namespace is the namespace argument value.
			Namespace string
			// Name is the name argument value.
			Name string
			// Options is the options argument value.
			Options *v1b.DeleteOptions
		}
		// Get holds details about calls to the Get method.
		Get []struct {
			// Namespace is the namespace argument value.
			Namespace string
			// Name is the name argument value.
			Name string
			// Options is the options argument value.
			Options v1b.GetOptions
		}
		// List holds details about calls to the List method.
		List []struct {
			// Namespace is the namespace argument value.
			Namespace string
			// Opts is the opts argument value.
			Opts v1b.ListOptions
		}
		// Patch holds details about calls to the Patch method.
		Patch []struct {
			// Namespace is the namespace argument value.
			Namespace string
			// Name is the name argument value.
			Name string
			// Pt is the pt argument value.
			Pt types.PatchType
			// Data is the data argument value.
			Data []byte
			// Subresources is the subresources argument value.
			Subresources []string
		}
		// Update holds details about calls to the Update method.
		Update []struct {
			// In1 is the in1 argument value.
			In1 *v1a.PersistentVolumeClaim
		}
		// UpdateStatus holds details about calls to the UpdateStatus method.
		UpdateStatus []struct {
			// In1 is the in1 argument value.
			In1 *v1a.PersistentVolumeClaim
		}
		// Watch holds details about calls to the Watch method.
		Watch []struct {
			// Namespace is the namespace argument value.
			Namespace string
			// Opts is the opts argument value.
			Opts v1b.ListOptions
		}
	}
}

// Create calls CreateFunc.
func (mock *PersistentVolumeClaimClientMock) Create(in1 *v1a.PersistentVolumeClaim) (*v1a.PersistentVolumeClaim, error) {
	if mock.CreateFunc == nil {
		panic("PersistentVolumeClaimClientMock.CreateFunc: method is nil but PersistentVolumeClaimClient.Create was just called")
	}
	callInfo := struct {
		In1 *v1a.PersistentVolumeClaim
	}{
		In1: in1,
	}
	lockPersistentVolumeClaimClientMockCreate.Lock()
	mock.calls.Create = append(mock.calls.Create, callInfo)
	lockPersistentVolumeClaimClientMockCreate.Unlock()
	return mock.CreateFunc(in1)
}

// CreateCalls gets all the calls that were made to Create.
// Check the length with:
//     len(mockedPersistentVolumeClaimClient.CreateCalls())
func (mock *PersistentVolumeClaimClientMock) CreateCalls() []struct {
	In1 *v1a.PersistentVolumeClaim
} {
	var calls []struct {
		In1 *v1a.PersistentVolumeClaim
	}
	lockPersistentVolumeClaimClientMockCreate.RLock()
	calls = mock.calls.Create
	lockPersistentVolumeClaimClientMockCreate.RUnlock()
	return calls
}

// Delete calls DeleteFunc.
func (mock *PersistentVolumeClaimClientMock) Delete(namespace string, name string, options *v1b.DeleteOptions) error {
	if mock.DeleteFunc == nil {
		panic("PersistentVolumeClaimClientMock.DeleteFunc: method is nil but PersistentVolumeClaimClient.Delete was just called")
	}
	callInfo := struct {
		Namespace string
		Name      string
		Options   *v1b.DeleteOptions
	}{
		Namespace: namespace,
		Name:      name,
		Options:   options,
	}
	lockPersistentVolumeClaimClientMockDelete.Lock()
	mock.calls.Delete = append(mock.calls.Delete, callInfo)
	lockPersistentVolumeClaimClientMockDelete.Unlock()
	return mock.DeleteFunc(namespace, name, options)
}

// DeleteCalls gets all the calls that were made to Delete.
// Check the length with:
//     len(mockedPersistentVolumeClaimClient.DeleteCalls())
func (mock *PersistentVolumeClaimClientMock) DeleteCalls() []struct {
	Namespace string
	Name      string
	Options   *v1b.DeleteOptions
} {
	var calls []struct {
		Namespace string
		Name      string
		Options   *v1b.DeleteOptions
	}
	lockPersistentVolumeClaimClientMockDelete.RLock()
	calls = mock.calls.Delete
	lockPersistentVolumeClaimClientMockDelete.RUnlock()
	return calls
}

// Get calls GetFunc.
func (mock *PersistentVolumeClaimClientMock) Get(namespace string, name string, options v1b.GetOptions) (*v1a.PersistentVolumeClaim, error) {
	if mock.GetFunc == nil {
		panic("PersistentVolumeClaimClientMock.GetFunc: method is nil but PersistentVolumeClaimClient.Get was just called")
	}
	callInfo := struct {
		Namespace string
		Name      string
		Options   v1b.GetOptions
	}{
		Namespace: namespace,
		Name:      name,
		Options:   options,
	}
	lockPersistentVolumeClaimClientMockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	lockPersistentVolumeClaimClientMockGet.Unlock()
	return mock.GetFunc(namespace, name, options)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//     len(mockedPersistentVolumeClaimClient.GetCalls())
func (mock *PersistentVolumeClaimClientMock) GetCalls() []struct {
	Namespace string
	Name      string
	Options   v1b.GetOptions
} {
	var calls []struct {
		Namespace string
		Name      string
		Options   v1b.GetOptions
	}
	lockPersistentVolumeClaimClientMockGet.RLock()
	calls = mock.calls.Get
	lockPersistentVolumeClaimClientMockGet.RUnlock()
	return calls
}

// List calls ListFunc.
func (mock *PersistentVolumeClaimClientMock) List(namespace string, opts v1b.ListOptions) (*v1a.PersistentVolumeClaimList, error) {
	if mock.ListFunc == nil {
		panic("PersistentVolumeClaimClientMock.ListFunc: method is nil but PersistentVolumeClaimClient.List was just called")
	}
	callInfo := struct {
		Namespace string
		Opts      v1b.ListOptions
	}{
		Namespace: namespace,
		Opts:      opts,
	}
	lockPersistentVolumeClaimClientMockList.Lock()
	mock.calls.List = append(mock.calls.List, callInfo)
	lockPersistentVolumeClaimClientMockList.Unlock()
	return mock.ListFunc(namespace, opts)
}

// ListCalls gets all the calls that were made to List.
// Check the length with:
//     len(mockedPersistentVolumeClaimClient.ListCalls())
func (mock *PersistentVolumeClaimClientMock) ListCalls() []struct {
	Namespace string
	Opts      v1b.ListOptions
} {
	var calls []struct {
		Namespace string
		Opts      v1b.ListOptions
	}
	lockPersistentVolumeClaimClientMockList.RLock()
	calls = mock.calls.List
	lockPersistentVolumeClaimClientMockList.RUnlock()
	return calls
}

// Patch calls PatchFunc.
func (mock *PersistentVolumeClaimClientMock) Patch(namespace string, name string, pt types.PatchType, data []byte, subresources ...string) (*v1a.PersistentVolumeClaim, error) {
	if mock.PatchFunc == nil {
		panic("PersistentVolumeClaimClientMock.PatchFunc: method is nil but PersistentVolumeClaimClient.Patch was just called")
	}
	callInfo := struct {
		Namespace    string
		Name         string
		Pt           types.PatchType
		Data         []byte
		Subresources []string
	}{
		Namespace:    namespace,
		Name:         name,
		Pt:           pt,
		Data:         data,
		Subresources: subresources,
	}
	lockPersistentVolumeClaimClientMockPatch.Lock()
	mock.calls.Patch = append(mock.calls.Patch, callInfo)
	lockPersistentVolumeClaimClientMockPatch.Unlock()
	return mock.PatchFunc(namespace, name, pt, data, subresources...)
}

// PatchCalls gets all the calls that were made to Patch.
// Check the length with:
//     len(mockedPersistentVolumeClaimClient.PatchCalls())
func (mock *PersistentVolumeClaimClientMock) PatchCalls() []struct {
	Namespace    string
	Name         string
	Pt           types.PatchType
	Data         []byte
	Subresources []string
} {
	var calls []struct {
		Namespace    string
		Name         string
		Pt           types.PatchType
		Data         []byte
		Subresources []string
	}
	lockPersistentVolumeClaimClientMockPatch.RLock()
	calls = mock.calls.Patch
	lockPersistentVolumeClaimClientMockPatch.RUnlock()
	return calls
}

// Update calls UpdateFunc.
func (mock *PersistentVolumeClaimClientMock) Update(in1 *v1a.PersistentVolumeClaim) (*v1a.PersistentVolumeClaim, error) {
	if mock.UpdateFunc == nil {
		panic("PersistentVolumeClaimClientMock.UpdateFunc: method is nil but PersistentVolumeClaimClient.Update was just called")
	}
	callInfo := struct {
		In1 *v1a.PersistentVolumeClaim
	}{
		In1: in1,
	}
	lockPersistentVolumeClaimClientMockUpdate.Lock()
	mock.calls.Update = append(mock.calls.Update, callInfo)
	lockPersistentVolumeClaimClientMockUpdate.Unlock()
	return mock.UpdateFunc(in1)
}

// UpdateCalls gets all the calls that were made to Update.
// Check the length with:
//     len(mockedPersistentVolumeClaimClient.UpdateCalls())
func (mock *PersistentVolumeClaimClientMock) UpdateCalls() []struct {
	In1 *v1a.PersistentVolumeClaim
} {
	var calls []struct {
		In1 *v1a.PersistentVolumeClaim
	}
	lockPersistentVolumeClaimClientMockUpdate.RLock()
	calls = mock.calls.Update
	lockPersistentVolumeClaimClientMockUpdate.RUnlock()
	return calls
}

// UpdateStatus calls UpdateStatusFunc.
func (mock *PersistentVolumeClaimClientMock) UpdateStatus(in1 *v1a.PersistentVolumeClaim) (*v1a.PersistentVolumeClaim, error) {
	if mock.UpdateStatusFunc == nil {
		panic("PersistentVolumeClaimClientMock.UpdateStatusFunc: method is nil but PersistentVolumeClaimClient.UpdateStatus was just called")
	}
	callInfo := struct {
		In1 *v1a.PersistentVolumeClaim
	}{
		In1: in1,
	}
	lockPersistentVolumeClaimClientMockUpdateStatus.Lock()
	mock.calls.UpdateStatus = append(mock.calls.UpdateStatus, callInfo)
	lockPersistentVolumeClaimClientMockUpdateStatus.Unlock()
	return mock.UpdateStatusFunc(in1)
}

// UpdateStatusCalls gets all the calls that were made to UpdateStatus.
// Check the length with:
//     len(mockedPersistentVolumeClaimClient.UpdateStatusCalls())
func (mock *PersistentVolumeClaimClientMock) UpdateStatusCalls() []struct {
	In1 *v1a.PersistentVolumeClaim
} {
	var calls []struct {
		In1 *v1a.PersistentVolumeClaim
	}
	lockPersistentVolumeClaimClientMockUpdateStatus.RLock()
	calls = mock.calls.UpdateStatus
	lockPersistentVolumeClaimClientMockUpdateStatus.RUnlock()
	return calls
}

// Watch calls WatchFunc.
func (mock *PersistentVolumeClaimClientMock) Watch(namespace string, opts v1b.ListOptions) (watch.Interface, error) {
	if mock.WatchFunc == nil {
		panic("PersistentVolumeClaimClientMock.WatchFunc: method is nil but PersistentVolumeClaimClient.Watch was just called")
	}
	callInfo := struct {
		Namespace string
		Opts      v1b.ListOptions
	}{
		Namespace: namespace,
		Opts:      opts,
	}
	lockPersistentVolumeClaimClientMockWatch.Lock()
	mock.calls.Watch = append(mock.calls.Watch, callInfo)
	lockPersistentVolumeClaimClientMockWatch.Unlock()
	return mock.WatchFunc(namespace, opts)
}

// WatchCalls gets all the calls that were made to Watch.
// Check the length with:
//     len(mockedPersistentVolumeClaimClient.WatchCalls())
func (mock *PersistentVolumeClaimClientMock) WatchCalls() []struct {
	Namespace string
	Opts      v1b.ListOptions
} {
	var calls []struct {
		Namespace string
		Opts      v1b.ListOptions
	}
	lockPersistentVolumeClaimClientMockWatch.RLock()
	calls = mock.calls.Watch
	lockPersistentVolumeClaimClientMockWatch.RUnlock()
	return calls
}

var (
	lockPersistentVolumeClaimCacheMockAddIndexer sync.RWMutex
	lockPersistentVolumeClaimCacheMockGet        sync.RWMutex
	lockPersistentVolumeClaimCacheMockGetByIndex sync.RWMutex
	lockPersistentVolumeClaimCacheMockList       sync.RWMutex
)

// Ensure, that PersistentVolumeClaimCacheMock does implement PersistentVolumeClaimCache.
// If this is not the case, regenerate this file with moq.
var _ v1.PersistentVolumeClaimCache = &PersistentVolumeClaimCacheMock{}

// PersistentVolumeClaimCacheMock is a mock implementation of PersistentVolumeClaimCache.
//
//     func TestSomethingThatUsesPersistentVolumeClaimCache(t *testing.T) {
//
//         // make and configure a mocked PersistentVolumeClaimCache
//         mockedPersistentVolumeClaimCache := &PersistentVolumeClaimCacheMock{
//             AddIndexerFunc: func(indexName string, indexer v1.PersistentVolumeClaimIndexer)  {
// 	               panic("mock out the AddIndexer method")
//             },
//             GetFunc: func(namespace string, name string) (*v1a.PersistentVolumeClaim, error) {
// 	               panic("mock out the Get method")
//             },
//             GetByIndexFunc: func(indexName string, key string) ([]*v1a.PersistentVolumeClaim, error) {
// 	               panic("mock out the GetByIndex method")
//             },
//             ListFunc: func(namespace string, selector labels.Selector) ([]*v1a.PersistentVolumeClaim, error) {
// 	               panic("mock out the List method")
//             },
//         }
//
//         // use mockedPersistentVolumeClaimCache in code that requires PersistentVolumeClaimCache
//         // and then make assertions.
//
//     }
type PersistentVolumeClaimCacheMock struct {
	// AddIndexerFunc mocks the AddIndexer method.
	AddIndexerFunc func(indexName string, indexer v1.PersistentVolumeClaimIndexer)

	// GetFunc mocks the Get method.
	GetFunc func(namespace string, name string) (*v1a.PersistentVolumeClaim, error)

	// GetByIndexFunc mocks the GetByIndex method.
	GetByIndexFunc func(indexName string, key string) ([]*v1a.PersistentVolumeClaim, error)

	// ListFunc mocks the List method.
	ListFunc func(namespace string, selector labels.Selector) ([]*v1a.PersistentVolumeClaim, error)

	// calls tracks calls to the methods.
	calls struct {
		// AddIndexer holds details about calls to the AddIndexer method.
		AddIndexer []struct {
			// IndexName is the indexName argument value.
			IndexName string
			// Indexer is the indexer argument value.
			Indexer v1.PersistentVolumeClaimIndexer
		}
		// Get holds details about calls to the Get method.
		Get []struct {
			// Namespace is the namespace argument value.
			Namespace string
			// Name is the name argument value.
			Name string
		}
		// GetByIndex holds details about calls to the GetByIndex method.
		GetByIndex []struct {
			// IndexName is the indexName argument value.
			IndexName string
			// Key is the key argument value.
			Key string
		}
		// List holds details about calls to the List method.
		List []struct {
			// Namespace is the namespace argument value.
			Namespace string
			// Selector is the selector argument value.
			Selector labels.Selector
		}
	}
}

// AddIndexer calls AddIndexerFunc.
func (mock *PersistentVolumeClaimCacheMock) AddIndexer(indexName string, indexer v1.PersistentVolumeClaimIndexer) {
	if mock.AddIndexerFunc == nil {
		panic("PersistentVolumeClaimCacheMock.AddIndexerFunc: method is nil but PersistentVolumeClaimCache.AddIndexer was just called")
	}
	callInfo := struct {
		IndexName string
		Indexer   v1.PersistentVolumeClaimIndexer
	}{
		IndexName: indexName,
		Indexer:   indexer,
	}
	lockPersistentVolumeClaimCacheMockAddIndexer.Lock()
	mock.calls.AddIndexer = append(mock.calls.AddIndexer, callInfo)
	lockPersistentVolumeClaimCacheMockAddIndexer.Unlock()
	mock.AddIndexerFunc(indexName, indexer)
}

// AddIndexerCalls gets all the calls that were made to AddIndexer.
// Check the length with:
//     len(mockedPersistentVolumeClaimCache.AddIndexerCalls())
func (mock *PersistentVolumeClaimCacheMock) AddIndexerCalls() []struct {
	IndexName string
	Indexer   v1.PersistentVolumeClaimIndexer
} {
	var calls []struct {
		IndexName string
		Indexer   v1.PersistentVolumeClaimIndexer
	}
	lockPersistentVolumeClaimCacheMockAddIndexer.RLock()
	calls = mock.calls.AddIndexer
	lockPersistentVolumeClaimCacheMockAddIndexer.RUnlock()
	return calls
}

// Get calls GetFunc.
func (mock *PersistentVolumeClaimCacheMock) Get(namespace string, name string) (*v1a.PersistentVolumeClaim, error) {
	if mock.GetFunc == nil {
		panic("PersistentVolumeClaimCacheMock.GetFunc: method is nil but PersistentVolumeClaimCache.Get was just called")
	}
	callInfo := struct {
		Namespace string
		Name      string
	}{
		Namespace: namespace,
		Name:      name,
	}
	lockPersistentVolumeClaimCacheMockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	lockPersistentVolumeClaimCacheMockGet.Unlock()
	return mock.GetFunc(namespace, name)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//     len(mockedPersistentVolumeClaimCache.GetCalls())
func (mock *PersistentVolumeClaimCacheMock) GetCalls() []struct {
	Namespace string
	Name      string
} {
	var calls []struct {
		Namespace string
		Name      string
	}
	lockPersistentVolumeClaimCacheMockGet.RLock()
	calls = mock.calls.Get
	lockPersistentVolumeClaimCacheMockGet.RUnlock()
	return calls
}

// GetByIndex calls GetByIndexFunc.
func (mock *PersistentVolumeClaimCacheMock) GetByIndex(indexName string, key string) ([]*v1a.PersistentVolumeClaim, error) {
	if mock.GetByIndexFunc == nil {
		panic("PersistentVolumeClaimCacheMock.GetByIndexFunc: method is nil but PersistentVolumeClaimCache.GetByIndex was just called")
	}
	callInfo := struct {
		IndexName string
		Key       string
	}{
		IndexName: indexName,
		Key:       key,
	}
	lockPersistentVolumeClaimCacheMockGetByIndex.Lock()
	mock.calls.GetByIndex = append(mock.calls.GetByIndex, callInfo)
	lockPersistentVolumeClaimCacheMockGetByIndex.Unlock()
	return mock.GetByIndexFunc(indexName, key)
}

// GetByIndexCalls gets all the calls that were made to GetByIndex.
// Check the length with:
//     len(mockedPersistentVolumeClaimCache.GetByIndexCalls())
func (mock *PersistentVolumeClaimCacheMock) GetByIndexCalls() []struct {
	IndexName string
	Key       string
} {
	var calls []struct {
		IndexName string
		Key       string
	}
	lockPersistentVolumeClaimCacheMockGetByIndex.RLock()
	calls = mock.calls.GetByIndex
	lockPersistentVolumeClaimCacheMockGetByIndex.RUnlock()
	return calls
}

// List calls ListFunc.
func (mock *PersistentVolumeClaimCacheMock) List(namespace string, selector labels.Selector) ([]*v1a.PersistentVolumeClaim, error) {
	if mock.ListFunc == nil {
		panic("PersistentVolumeClaimCacheMock.ListFunc: method is nil but PersistentVolumeClaimCache.List was just called")
	}
	callInfo := struct {
		Namespace string
		Selector  labels.Selector
	}{
		Namespace: namespace,
		Selector:  selector,
	}
	lockPersistentVolumeClaimCacheMockList.Lock()
	mock.calls.List = append(mock.calls.List, callInfo)
	lockPersistentVolumeClaimCacheMockList.Unlock()
	return mock.ListFunc(namespace, selector)
}

// ListCalls gets all the calls that were made to List.
// Check the length with:
//     len(mockedPersistentVolumeClaimCache.ListCalls())
func (mock *PersistentVolumeClaimCacheMock) ListCalls() []struct {
	Namespace string
	Selector  labels.Selector
} {
	var calls []struct {
		Namespace string
		Selector  labels.Selector
	}
	lockPersistentVolumeClaimCacheMockList.RLock()
	calls = mock.calls.List
	lockPersistentVolumeClaimCacheMockList.RUnlock()
	return calls
}
